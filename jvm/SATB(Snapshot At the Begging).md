# SATB(Snapshot At the Begging)

SATB，也可以称为对象快照技术，在GC之前对整个堆进行一次对象索引关系，形成位图，相当于堆的逻辑快照。在并并发回收过程中，通过增量的方式维护这个对象位图。

    1.SATB解决了什么问题？
    主要是为了解决并发标记过程中，出现的漏标，误标等问题。
    
    2.什么是漏标，误标。
    在并发标记过程中，APP线程跟GC线程同时进行，GC线程扫描的时候发现一个对象位垃圾对象，不对他进行标记，而APP线程马上就会操作索引指向这个对象。那么在垃圾回收的时候这样漏标的对象被回收就会产生灾难性的后果。也有的情况就是，在GC标记完一个对象不需要回收之后，APP线程之后就会把所有指向这个对象的索引完全去除，那么这就是一个垃圾对象，然而在回收过程之中并没有回收，造成了浮动垃圾，这种情况就是误标。
    
    3.漏标、误标的解决方案。
    解决漏标误标，就必须了解两个名词。第一个名词：三色标记法，第二个名词：writer barrier（写栅栏）
    首先解释第一个名词：三色标记算法
    首先我们知道无论是 g1还是CMS垃圾标记算法都叫做根可达（root searching），首先搜索比如 线程栈上的对象、静态变量、常量池中的对象以及jni指针，这个部分往往发生是G1的初始标记阶段，会进行STW。然后就进入了并发标记阶段。首先我们定义：扫描过当前对象以及其子索引对象的为不可回收的对象位黑色对象，有黑色父对象索引指向的，并且未扫描其子索引的对象为灰色对象，需要回收的对象：为白色对象。
    
    第二个名词：写栅栏：write barrier
    当上图中 B->C 改变成 A->C 的索引，垃圾回收器是如何感知的？就是通过writer barrier技术，其实就相当于一个钩子程序，但执行索引改变的时候，触发一下write barrier，然后write barrier根据相应的需求增加一条索引更改的日志。每个App现场都会有一个LTB（local thread buffer）当一个LTB缓冲区写满之后，就新起一个缓冲区，把原来的缓冲区写入全局缓冲中，又相应的垃圾回收线程去更新SATB 的对象快照图。
## SATB + RSet 解决了什么问题？

```
上面说了三色标记算法，为了解决漏标问题提出了一个writeBarrier的解决方案。但是还是有一种情况的漏标是writeBarrier解决不了的。就是在并发的情况下，当一个线程扫描对象A，对象A有索引：A->B,A->C，其中线程T1，扫描完B在扫描C的状态中，此时有个线程T2把索引B改动，改成A->D，把A设置为灰色，此时T1把C扫描完了，把A设置为黑色。这时我们就发现黑色对象A，下面就会有一个白色对象D未扫描。那么这样的漏标如何解决？
SATB位图构建过程中，所有有索引改动的对象，如上面所说的D跟B，就放入一个队列中。当Remark阶段，扫描这个队列里面的所有对象，重新标记。但是重新标记，按照道理来说，我们又需要扫描整个堆，但是我们其实只想回收某一个Region，又去扫描整个堆效率上来说肯定是不行的。这个时候，我们就可以去扫描Region中的RSet，如果RSet 没有记录其他Region对这个对象的索引，自己内部也没有，那么这个对象就是一个可回收的垃圾对象。

CMS中通过incremental update解决了部分漏标问题，但是像这样并发情况的下的漏标是不能解决的。所以为了解决可能存在的漏标问题，也是通过WriterBarrier，将A这样有改变过索引的对象放入一个堆栈中，在AbortPreClean、Remark阶段重新扫描一次这些对象。
```

