#### 事务特性

* 原子性(```Atomicity```)：全部成功或者全部失败。

  通过undo log 日志来实现。当操作发生异常时，可以通过undo log 来进行回滚，保证整个事务中的操作要么全部成功或者全部失败。

* 隔离性(```Isolation```)：并行事务之间互不干扰。通过MVCC和读写锁来实现。

* 持久性(```Durability```)：事务提交后，永久生效。通过redo log 来实现。

* 一致性(```Consistency```)：一致性是指事务将数据库从一种状态转变为下一种一致的状态。在事务开始之前和事务结束之后，数据库的完整性约束没有被破坏(通过```AID```保证)。

#### 并发问题

* 脏读(```Dirty Read```)：读取到了未提交的数据。

* 不可重复读(```Non-repeatable Read```)：两次读取结果不一致。

  | 事务```T1```                                         | 事务```T2```                        |
  | ---------------------------------------------------- | ----------------------------------- |
  | 查询表```t1```总数，返回100                          |                                     |
  |                                                      | 向表```t1```插入1条数据，提交事务。 |
  | 再次查询表```t1```总数，返回101,两次查询结果不一致。 |                                     |

* 幻读(```Phantom Read```)：所谓幻读是同一个事务连续做两次**当前读**，那么这两次当前读返回的是完全相同的记录，第二次当前读不会比第一次返回更多的记录。mysql中当前读通过gap锁保证不出现幻读，快照读通过mvcc保证每次读的数据不会变。


#### 隔离级别

* Read Uncommitted(读取未提交内容)：最低隔离级别，会读取到其他事务未提交的数据，脏读。
* Read Committed(读取提交内容)：事务过程中可以读取到其他事务提交的数据，不可重复读。
* Repeatable Read（可重复读）：每次读取相同结果集，不管其他事务是否提交，幻读。在mysql innodb中幻读不存在。
* Serializable(可串行化)：事务排队，隔离级别最高，性能最差。

#### MVCC多版本并发控制(Multi-Version Concurrency Control)

MVCC-多版本控制，主要是在当前读与快照读发生冲突时，快照读根据undo log 读取相关的快照。通过这种方式，不用加锁，也能正常读取数据，提高了数据库的并发能力。

* 当前读：读取记录的最新版本，读取时还要保证其他事务不能修改当前记录，会对读取的记录进行加锁。插入/更新/删除操作，属于当前读，需要加锁。

  ```sql
  select * from t for update 
  ```

  插入/更新/删除操作，属于当前读，需要加锁在数据库中的执行流程：

  ![](../images/sql/13.jpg)

  ​	从图中，可以看到，一个Update操作的具体流程。当Update SQL被发给MySQL后，MySQL  Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current  read)。待MySQL  Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。

  注：根据上图的交互，针对一条当前读的SQL语句，InnoDB与MySQL Server的交互，是一条一条进行的，因此，加锁也是一条一条进行的。先对一条满足条件的记录加锁，返回给MySQL Server，做一些DML操作；然后在读取下一条加锁，直至读取完毕

* 快照读：基于多版本，即快照读可能读取到的并不一定是数据的最新版本，有可能是之前的历史版本。

  ```sql
  select * from t
  ```

![](../images/sql/1.png)

**Read View**

> 当事务开启时，会分配一个id，这个id是递增的，所以最新的事务，id越大。
>
> 生成的视图中包含最大活跃事务id、最小活跃事务id、当前活跃的事务Id列表、当前事务id。

当事务进行快照读(select * from)操作时，会产生的一个读视图，该视图维护行数据当前活跃事务(未提交)的Id，我们把它比作条件来判断当前事务能够看到哪个版本的数据，即可能是当前最新的数据，也有可能是该行记录的某个版本的数据。

可见性判断：

* 如果被访问版本的trx_id与当前事务id值相同，说明在访问它自己修改过的记录，所以该版本可以被当前事务访问。
* 如果被访问的版本的trx_id小于最小id，说明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
* 如果被访问的版本的trx_id大于最大id，说明生成该版本的事务在当前事务生成ReadView后开启的，当前版本不能访问。
* 如果被访问的trx_id在最大和最小id之间，那就需要判断一下，该事务id是否在活跃列表中，如果不在，则可以被访问，否则不能访问。

![](../images/sql/2.png)

#### 不同隔离级别的实现

* 读未提交

  读最新的数据，不管这条数据是不是已提交。不会遍历版本链，少了查找可见版本的步骤。可能会导致脏读。

* 可重复读。MYSQL的默认隔离级别。

  事务在开始时创建一个ReadView，当读一条记录时，会遍历版本链表，通过当前事务的ReadView判断可见性。

* 读已提交。

  获取ReadView的时机，每个语句开始执行时，获得ReadView，可见性判断是基于语句级别的ReadView。读的策略与可重复读类似。

* 串行读，快照读退化成当前读，每次读取都需要加锁。



#### 事务的实现

**undo log**

* 回滚日志。

* 保证事务原子性。

* 实现数据多版本。

* insert undo log：用于回滚，提交即清理。

  > 新插入的每一行的事务id为当前事务id。

* update undo log：用于回滚，同时实现快照读，不能随便删除。

  > InnoDB 为新插入一行新记录，将行记录上的事务id更新为当前事务id，同时将当前事务id保存到原来的行作为删除标记。
  >
  > delete 一条数据时，将当前事务id作为删除标记保存到行记录上，最终删除操作由purge线程完成。

![](../images/sql/3.png)

> purge线程两个主要作用是：清理undo页和清除page里面带有Delete_Bit标识的数据行。在InnoDB中，事务中的Delete操作实际上并不是真正的删除掉数据行，而是一种Delete Mark操作，在记录上标识Delete_Bit，而不删除记录。是一种"假删除",只是做了个标记，真正的删除工作需要后台purge线程去完成

**redo log**

* 实现事务持久性。

* 记录修改。

* 用于异常恢复。

* 循环写文件。

  * write pos：写入位置。
  * chick point：刷盘位置。
  * chick point -> write pos ：待落盘数据。

  ![](../images/sql/4.png)

* 写入流程

  * 记录页的修改，状态为prepare。
  * 事务提交，将事务记录为commit状态。

  ![](../images/sql/5.png)

* 刷盘时机

  * innodb_flush_log_at_trx_commit

  ![](../images/sql/6.png)





1. redo 

在InnoDB存储引擎中，事务日志通过重做(redo)日志文件和InnoDB存储引擎的日志缓冲(InnoDB Log Buffer)来实现。

当事务开始时，会记录该事务的一个LSN(Log Sequence Number,日志序列号)，当事务执行时，会往InnoDB 存储引擎的日志缓冲中插入事务日志，然后当事务提交时，再将InnoDB日志缓冲写入磁盘。但是在写数据之前，需要写重做日志，这意味着磁盘上的数据页和内存缓冲池中的页是不同步的，对于内存缓冲池中页的修改，先是写入重做日志文件，然后再写入磁盘，这是一种异步的方式。

可以通过命令show engine indoor status来观察当前磁盘和日志的差距：

```
show engine innodb status\G

LOG
---
Log sequence number 2999068
Log flushed up to   2999068
Pages flushed up to 2999068
Last checkpoint at  2999068
0 pending log writes, 0 pending chkp writes
12 log i/o's done, 0.00 log i/o's/second

```

Log sequence number表示当前的LSN，Log flushed up to 表示刷新到重做日志文件的LSN，Last checkpoint at表示刷新到磁盘的LSN。因为目前没有任何操作，所以这三者的值是一样的。

接下来我们创建一张表来模拟数据的插入，来观察磁盘日志和日志的差距

创建表和存储过程：

```
create table z(a int,primary key(a)) engine=innodb;

delimiter $$
create procedure load_test(count int) begin declare i int unsigned default 0; start transaction; while i < count do insert into z select i; set i=i+1; end while; commit;  end$$
delimiter ;
```

插入1000000数据后再观察

```
call load_test(1000000);
show engine innodb status\G;

LOG
---
Log sequence number 53124451
Log flushed up to   53124451
Pages flushed up to 20726036
Last checkpoint at  20726036
0 pending log writes, 0 pending chkp writes
56 log i/o's done, 0.95 log i/o's/second
```

这次结果就不同了，可以把Log flushed up to与Last checkpoint at的差值理解为重做日志产生的增量。

上面的Log sequence number与Log flushed up to虽然是相等的，但是在实际生产环境中，该值有可能是不同的。因为在一个事务中从日志缓冲刷新到重做日志文件，并不是在事务提交时发生，每秒都会有从日志缓冲刷新到重做日志文件的动作。



