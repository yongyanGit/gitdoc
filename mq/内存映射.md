# 内存映射

## mmap

 **mmap** ，也就是内存映射 。内存映射是将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容的过程。

### 1.1 基础概念

先讲下内存映射里的一些概念。

虚拟内存区域可以映射以下两种类型的对象：

1. 普通文件：即磁盘文件中的一块 **连续** 的区域。
2. 匿名文件：一个由内核创建的全为 **二进制零** 的文件。当CPU首次引用此区域时，将以二进制零填充到页表中。

系统为每个进程提供了单独的页表，从而也实现了进程间数据访问权限的管理以及数据的保护。通过内存映射的机制，将对象作为 **共享对象** 映射到两个进程的虚拟内存亦可实现数据的共享。

![](../images/mq/43.jpg)

### 2.2 使用方式

然后先讲下如果我们应该如何通过内存映射的方式来访问文件。 **mmap()** 的函数定义如下：

```c
void * mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset)
```

其中参数的含义分别是：

    start: 期望的进程虚拟内存起始位置，填 NULL 时由内核来决定起始位置
    length: 需要映射的对象字节大小
    fd: 文件句柄
    offset: 距离文件开始处的偏移量
    prot: 映射对象的访问权限，用于可指定是否可读写、执行。
    flags: 映射对象的类型，例如指定是映射普通文件还是请求二进制零、映射共享对象还是私有的写时复制对象等。
![](../images/mq/44.jpg)

1.3 读取过程

当我们通过 mmap 读取文件时，将经历以下步骤：

1. 在当前用户虚拟内存空间中分配一片 指定映射大小 的虚拟内存区域
2. 将磁盘中的文件映射到这片内存区域，等待后续 按需 进行页面调度
3. 当CPU真正访问数据时，触发 缺页异常 将所需的数据页从磁盘拷贝到物理内存，并将物理页地址记录到页表。
4. 进程通过页表得到的物理页地址访问文件数据。

![](../images/mq/45.jpg)

而作为对比，当通过 **标准IO** 读取一个文件时，步骤为：

1. 将 **完整** 的文件从磁盘拷贝到物理内存（内核空间）。
2. 将完整文件数据从 **内核空间** 拷贝到 **用户空间** 以供进程访问。

![](../images/mq/46.jpg)

2.4 优劣

通过上面 mmap 与 标准IO 的对比，不难发现调用mmap具有以下的优势：

1. 物理内存占用延后：数据直到真正被使用时才会发生拷贝。
2. 物理内存占用减少：对于同一份文件无需在物理内存中存放两份，且文件区被划分成片，缺页异常时只将所需的页拷贝到物理内存。
3. 方便实现跨进程数据交互、共享：当映射到虚拟内存的对象被设置为共享对象，则不同进程对映射对象的写操作相互可见

然而也能发现 mmap 存在以下 劣势 ：

1. 无法映射变长文件：调用mmap()时需指定要映射的文件位置和需要映射的大小范围。
2. 如果需要映射的文件过大，会导致过度占用虚拟内存：在调用mmap()后，虚拟内存空间就创建了，此时虽然不会占用物理内存，但依然会占用虚拟内存。此时可考虑只映射文件中自己需要的部分。

由此，当我们需要访问一个比较大的文件，尤其是当我们只需要访问其中的一小部分数据的时候，我们可以尝试通过 mmap 的方式来进行访问，减少由于该文件过大而对物理内存的过度占用。

## 共享内存映射

现在考虑林一种处理方法：进程A和进程B都将该页映射到自己的地址空间，当进程A第一次访问该页中的数据时，它生成一个缺页终端，内核此时读入这一页到内存并更新页表使之指向它，以后，当进程B访问同一页面而出现缺页中断时，该页已经在内存，内核只需要将进程B的页表登记项指向次页即可。

![](../images/mq/47.png)

## **mmap及其相关系统调用**

mmap()系统调用使得进城之间通过映射同一个普通文件实现共享内存。普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对文件进行访问，不必再调用read,write等操作。

mmap的作用是映射文件描述符和指定文件的(off_t off)区域至调用进程的(addr,addr *len)的内存区域，如下图所示：

![](../images/mq/48.png)

参数：

fd：为即将映射到进程空间的文件描述字，一般由open()返回，同时，fd可以指定为-1,此时须指定flags参数中的MAP_ANON，表明进行的是匿名映射(不涉及具体的文件名，避免了文件的创建及打开，很显然只能用于具有亲缘关系的进程间进行通信)。

len：是映射到调用进程地址空间的字节数，它从被映射文件开头offset个字节开始算起。

prot：指定空想内存的访问权限。可取如下几个值的或：PROT_READ(可读)、PROT_WRITE(可写)、PROT_EXEC(可执行)、PROT_NONE(不可访问)。

flag:由以下几个常值指定：MAP_SHARED、MAP_PRIVATE、MAP_FIXED,其中，MAP_SHARED，MAP_PRIVATE必选其一，而MAP_FIXED则不推荐使用。

offset：一般设为0，表示从文件头开始映射。

addr：指定文件应被映射到进程空间的起始地址，一般被指定一个空指针，此时选择起始地址的任务留给内核来完成。

例子：

```c
#include <sys/mman.h>
#include <sys/stat.h>
#include<fcntl.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<error.h>
 
int main(int argc, char * argv[])
{
     int fd, nread;
     struct stat sb;
     char *mapped;
 
//打开文件
      if((fd = open(argv[1], O_RDWR)) < 0){
           perror("open") ;
      }   
 
//获取文件的属性
      if((fstat(fd, &sb)) == -1 ){
           perror("fstat") ;
      }   
      
     
//将文件映射至进程的地址空间
      if((mapped = mmap(NULL, sb.st_size, PROT_READ|\
               PROT_WRITE, MAP_SHARED, fd, o)) ==(void*) -1){
           perror("mmap") ;
      }   
     
//修改一个字符，同步到磁盘文件
      mapped[20] = '9';
      if((msync((void *)mapped, sb.st_size, MS_SYNC)) == -1){
           perror("msync") ;
      
//释放存储映射区
      if((munmap((void *)mapped,sb.st_size)) == -1){
           perror("munmap");  
      }   
                 
      return 0;
}
```