 ### 消息队列

#### 消息队列的作用

* 业务解耦：将模块间的RPC调用改为通过消息队列中转，解除系统间的耦合。

  作用：提升系统稳定性，通过广播消息避免多次调用，提供编码效率。

  ![](../images/mq/1.png)

  

* 异步调用：对于无需关注调用结果的场景，可以通过消息队列异步处理。

  未使用消息队列前，全部使用rpc调用：

  ![](../images/mq/2.png)

  如下图，使用消息队列后，向卖家推消息和记录交易数据通过mq来异步调用：

  ![](../images/mq/3.png)

* 流量削峰：系统的吞吐量往往取决于底层存储服务的处理能力，数据访问层可以调整消费速度缓解存储服务压力，避免短暂的高峰将系统压垮。

  ![](../images/mq/4.png)

#### 对系统架构的影响

* 系统可用性，系统依赖于mq，mq的不可用会影响系统的可用性。
* 架构复杂度。
* 排查问题路径。

#### RocketMQ架构

* Broker 主从部署，自身信息注册在NameServer中。
* Client从NameServer中获取Broker信息。
* NameServer节点相互独立，无数据交互。

拓扑图：Broker Master 和Broker Slave 都向Name Server集群注册，Producer集群从Name Server集群获取Broker 集群信息，然后向Broker Master写入数据；Consumer同样从Name Server拉取集群信息，同时向Broker Master 和Broker Slave注册监听，这样的好处是当master不可用时，Consumer 还可以读取数据

![](../images/mq/6.png)

RocketMQ架构图：

![](../images/mq/7.png)

#### 消息存储

* CommitLog：存储信息主体。生产者顺序写入到CommitLog文件中。当CommitLog文件过大时，会对该文件进行切割，默认是1G。消费者在读消息时，可以将分割后的文件加载到内存中。
* ConsumeQueue：消息消费队列。RocketMQ通过dispatch顺序将消息的迁移位置，消息的大小分发到消息队列，然后消费者通过迁移位置读取真正的消息。minOffset最小消息迁移位置表示在队列中已读取还没有提交的数据，consumerOffset还没有读取的消息，maxOffset队列的最大位置。
* IndexFile：消息索引位置。

![](../images/mq/8.png)



#### 特性分析

* 可靠性分析，可靠性分为写入master的刷盘时机和master同步到slave的方式。

  * 同步刷盘：当消息存储到硬盘后，再返回ack。性能低，可靠性高。

    ![](../images/mq/9.png)

  * 异步刷盘：性能高，可靠性低。

    ![](../images/mq/10.png)

  * 异步复制：master异步复制到从库。

  * 同步双写：mater和slave写成功后才返回ack

* 可用性分析。

  * 单Master模式。开发、测试环境使用。
  * 多Master模式。Master不可用，因为没有slave，可能会导致数据丢失。
  * 多Master多Slave模式-异步复制。主从模式，Master宕机，Broker可读不可写。
  * 多Master多Slave模式-同步双写。

* 生产方式：

  * 同步(sync)：生成者发送消息到队列后，同步阻塞等待broker响应。
  * 异步(aync)：异步回传响应。
  * 单向(oneway)：生成者将消息发送到队列，不管消息有没有丢失。

* 消费方式：

  * push：消息队列主动将消息推送给消费者。消息实时性高，但没有考虑客户端的消费能力。
  * pull：由消费者客户端主动向消息队列拉取消息。消息实时性低，可能造成大量无效请求。

  RecketMQ的消费模式属于拉模式，但是使用了一种长轮询机制，来平衡上面的push/pull模型的各自缺点。

  * LongPoll：Consumer发送拉取消息，Broker hold住请求，直到有新消息再返回；如果请求超时，Consumer再次发起请求，请求超时默认30s。

  **消息消费方式**

  > Group 内竞争Group间广播

  * 集群消费：集群内竞争消费，单条消息只消费一次，各节点均匀消费Topic的消息
  * 广播消费：各集群消费全量的消息，单条消息在每个集群都会被消费一次。

* 负载均衡

  * Producer端负载均衡：

    定时获取Queue信息。

    负载均衡算法：随机递增取模

    容错机制：故障延迟。发送队列失败会进行重试，重试时间一次比一次长。

  * Consumer端负载均衡：

    客户端定时上报心跳，

    定时Rebalance(20s)，即重新负载均衡:

    * 获取队列信息

    * 获取消费者信息

    * 排序平均消费

      ![](../images/mq/11.png)

* 消费失败策略：消费失败后，消息会被投递到重试队列，如果重试还是一直失败，说明客户端无法消费该信息，将消息投递到死信队列，等待运营处理。

  * 重试16次。
  * 重试时间间隔递增
  * 失败进入死信队列。

  实现原理：

  * 自动创建失败消息主题
  * 客户端默认订阅
  * 结合延时消息实现重试间隔

   











qq